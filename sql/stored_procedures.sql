CREATE OR REPLACE PROCEDURE SP_READ_JSON_METADATA()
RETURNS STRING
LANGUAGE SQL
AS
$$
INSERT INTO METADATA_JSON_STRUCTURE
SELECT DISTINCT
    f.key,
    f.path,
    TYPEOF(f.value),
    f.index,
    CURRENT_TIMESTAMP()
FROM LANDING_JSON,
LATERAL FLATTEN(input => RAW[0]) f;
--RETURN 'JSON METADATA LOADED';
$$;

CREATE OR REPLACE PROCEDURE SP_VALIDATE_SCHEMA()
RETURNS STRING
LANGUAGE SQL
AS
$$
INSERT INTO METADATA_SCHEMA_CHANGES(FIELD_NAME, JSON_PATH, CHANGE_TYPE)
SELECT FIELD_NAME, JSON_PATH, 'NEW_FIELD',NULL,DATA_TYPE
FROM METADATA_JSON_STRUCTURE m
LEFT JOIN METADATA_TABLE_DEFINITION t
ON m.JSON_PATH = t.JSON_PATH
WHERE t.JSON_PATH IS NULL;
--RETURN 'SCHEMA VALIDATION COMPLETE';
$$;

CREATE OR REPLACE PROCEDURE SP_LOAD_CUSTOMER()
RETURNS STRING
LANGUAGE SQL
AS
$$
MERGE INTO CUSTOMER tgt
USING (
    SELECT
      RAW[0]:id::INT AS ID,
      RAW[0]:name::STRING AS NAME,
      RAW[0]:email::STRING AS EMAIL,
      RAW[0]:age::INT AS AGE,
      RAW[0]:is_active::BOOLEAN AS IS_ACTIVE,
      RAW[0]:signup_date::DATE AS SIGNUP_DATE,
      RAW[0]:address.street::STRING AS STREET,
      RAW[0]:address.city::STRING AS CITY,
      RAW[0]:address.state::STRING AS STATE,
      RAW[0]:address.zip::STRING AS ZIP
    FROM LANDING_JSON
) src
ON tgt.ID = src.ID
WHEN MATCHED THEN UPDATE SET
    NAME = src.NAME,
    EMAIL = src.EMAIL,
    AGE = src.AGE,
    IS_ACTIVE = src.IS_ACTIVE,
    SIGNUP_DATE = src.SIGNUP_DATE,
    STREET = src.STREET,
    CITY = src.CITY,
    STATE = src.STATE,
    ZIP = src.ZIP
WHEN NOT MATCHED THEN INSERT VALUES
(
    src.ID, src.NAME, src.EMAIL, src.AGE, src.IS_ACTIVE,
    src.SIGNUP_DATE, src.STREET, src.CITY, src.STATE, src.ZIP
);
--RETURN 'CUSTOMER LOADED';
$$;

CREATE OR REPLACE PROCEDURE SP_LOAD_ORDERS()
RETURNS STRING
LANGUAGE SQL
AS
$$
MERGE INTO ORDERS tgt
USING (
    SELECT
        RAW[0]:id::INT AS CUSTOMER_ID,
        o.value:order_id::STRING AS ORDER_ID,
        o.value:amount::NUMBER(10,2) AS AMOUNT,
        o.value:order_date::DATE AS ORDER_DATE
    FROM LANDING_JSON,
    LATERAL FLATTEN(input => RAW[0]:orders) o
) src
ON tgt.CUSTOMER_ID = src.CUSTOMER_ID
AND tgt.ORDER_ID = src.ORDER_ID
WHEN MATCHED THEN UPDATE SET
    AMOUNT = src.AMOUNT,
    ORDER_DATE = src.ORDER_DATE
WHEN NOT MATCHED THEN INSERT VALUES
(
    src.CUSTOMER_ID, src.ORDER_ID, src.AMOUNT, src.ORDER_DATE
);
--RETURN 'ORDERS LOADED';
$$;

CREATE OR REPLACE PROCEDURE SP_LOAD_ORDER_ITEMS()
RETURNS STRING
LANGUAGE SQL
AS
$$
MERGE INTO ORDER_ITEMS tgt
USING (
    SELECT
        RAW[0]:id::INT AS CUSTOMER_ID,
        o.value:order_id::STRING AS ORDER_ID,
        i.value::STRING AS ITEM_NAME
    FROM LANDING_JSON,
    LATERAL FLATTEN(input => RAW[0]:orders) o,
    LATERAL FLATTEN(input => o.value:items) i
) src
ON tgt.CUSTOMER_ID = src.CUSTOMER_ID
AND tgt.ORDER_ID = src.ORDER_ID
AND tgt.ITEM_NAME = src.ITEM_NAME
WHEN MATCHED THEN UPDATE SET
    ITEM_NAME = src.ITEM_NAME
WHEN NOT MATCHED THEN INSERT VALUES
(
    src.CUSTOMER_ID, src.ORDER_ID, src.ITEM_NAME
);
--RETURN 'ORDER_ITEMS LOADED';
$$;

CREATE OR REPLACE PROCEDURE SP_AUDIT(RUN_ID STRING)
RETURNS STRING
LANGUAGE SQL
AS
$$
INSERT INTO AUDIT_LOG
SELECT
    :RUN_ID,
    (SELECT FILE_NAME FROM LANDING_JSON LIMIT 1),
    (SELECT COUNT(*) FROM LANDING_JSON),
    (SELECT COUNT(*) FROM CUSTOMER),
    (SELECT COUNT(*) FROM ORDERS),
    (SELECT COUNT(*) FROM ORDER_ITEMS),
    'SUCCESS',
    (SELECT COUNT(*) FROM METADATA_SCHEMA_CHANGES WHERE PROCESSED_FLAG='N'),
    CURRENT_TIMESTAMP(),
    CURRENT_TIMESTAMP(),
    'LOAD COMPLETED';
--RETURN 'AUDIT COMPLETE';
$$;
CREATE OR REPLACE PROCEDURE SP_LOAD_DATA()
RETURNS STRING
LANGUAGE SQL
AS
$$
BEGIN
  COPY INTO LANDING_JSON(RAW, FILE_NAME, LOAD_TS)
  FROM (
    SELECT $1, METADATA$FILENAME, CURRENT_TIMESTAMP()
    FROM @raju_stage
  )
  FILE_FORMAT = (TYPE = 'JSON')
  ON_ERROR = 'CONTINUE';
END;
$$;
